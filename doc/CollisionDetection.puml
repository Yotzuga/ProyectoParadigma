@startuml CollisionDetection
!theme plain

participant "CollisionSystem" as CS
participant "World" as W
participant "CollisionResponseSystem" as CRS
participant "DamageSystem" as DMG

== COLLISION DETECTION ==

note over CS
    Itera sobre entidades con ColliderComponent
end note

CS -> W: GetEntitiesWithComponent<Collider>()
note right of W
    Retorna vector de entidades
    con componente ColliderComponent
end note

loop Para cada par (i, j) donde i < j
    
    alt Ambos tienen Collider && Transform
        
        CS -> CS: AABB_Check(entity_i, entity_j)
        note right of CS
            Obtener bounding boxes:
            box_i = (x_i, y_i, width_i, height_i)
            box_j = (x_j, y_j, width_j, height_j)
            
            Fórmula AABB:
            i.x < j.x + j.width AND
            i.x + i.width > j.x AND
            i.y < j.y + j.height AND
            i.y + i.height > j.y
        end note
        
        alt ¡COLISIÓN DETECTADA!
            
            CS -> CS: CalculateOverlap()
            note right of CS
                overlap_x = min(
                    i.x + i.width - j.x,
                    j.x + j.width - i.x
                )
                overlap_y = min(
                    i.y + i.height - j.y,
                    j.y + j.height - i.y
                )
            end note
            
            note right of CS
                Almacenar colisión en lista:
                collisions.push({entity_i, entity_j,
                  overlap_x, overlap_y})
            end note
            
        else Sin colisión
            note right of CS
                AABB no intersecta
                Continuar verificando
            end note
        end
        
    end
end

note over CS, W
    FASE 1 COMPLETADA
    Lista de colisiones detectada
end note

== COLLISION RESPONSE ==

CRS -> CRS: Para cada colisión en lista
note right of CRS
    Procesar las colisiones detectadas
end note

loop Para cada colisión (e1, e2, ox, oy)
    
    CRS -> CRS: DeterminePushAxis()
    note right of CRS
        if (overlap_x < overlap_y) {
            push en eje X
        } else {
            push en eje Y
        }
    end note
    
    alt Push en eje X
        CRS -> CRS: direction = sign(e1.x - e2.x)
        CRS -> CRS: push_e1 = overlap_x * PUSH_STRENGTH * direction
        CRS -> CRS: push_e2 = -push_e1
    else Push en eje Y
        CRS -> CRS: direction = sign(e1.y - e2.y)
        CRS -> CRS: push_e1 = overlap_y * PUSH_STRENGTH * direction
        CRS -> CRS: push_e2 = -push_e1
    end
    
    CRS -> CRS: e1.transform.pos += push
    CRS -> CRS: e2.transform.pos += push
    note right of CRS
        Separar cuerpos que se overlappean
    end note
    
end

note over CRS
    FASE 2 COMPLETADA
    Cuerpos separados
end note

== DAMAGE APPLICATION ==

DMG -> DMG: Para cada colisión (e1, e2)
note right of DMG
    Determinar si es colisión de daño:
    - Player vs Enemy → Player toma daño
    - Enemy vs Obstacle → No hace nada
    - Player vs Obstacle → No hace daño
end note

alt e1 = Player AND e2 = Enemy
    DMG -> DMG: if (!Player.isInvulnerable) {
    DMG -> DMG:   Player.takeDamage(Enemy.damage)
    DMG -> DMG:   Player.setInvulnerable(time)
    DMG -> DMG: }
else alt e1 = Enemy AND e2 = Player
    DMG -> DMG: if (!Player.isInvulnerable) {
    DMG -> DMG:   Player.takeDamage(Enemy.damage)
    DMG -> DMG:   Player.setInvulnerable(time)
    DMG -> DMG: }
else
    DMG -> DMG: Sin daño aplicable
end

DMG -> DMG: if (Player.health <= 0) {
DMG -> DMG:   m_GameOver = true
DMG -> DMG: }

note over DMG
    FASE 3 COMPLETADA
    Daño aplicado, game over determinado
end note

CRS -> E2: transform.pos -= direction * separation
note right of E2
    Entidad 2 se aleja
end note

CRS -> Q: EmitEvent(DamageEvent)
note right of Q
    Evento de daño emitido
    Enqueued para próximo frame
end note

note over CRS, Q
    RESPONSE COMPLETADO
    Entidades separadas
    Daño calculado
end note

@enduml
